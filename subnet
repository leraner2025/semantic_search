import re
import subprocess
from typing import Iterable, Optional, Dict, Any, List
import networkx as nx
import requests
from concurrent.futures import ThreadPoolExecutor, as_completed

# Replace with your real API base URL
URL = url1

# CUI regex
CUI_RE = re.compile(r"^C\d{7}(?:-\d+)?$")


class AugmentCUI:
    def __init__(self, url: str = URL):
        self.url = url

    # ---------------- Authentication ----------------
    def get_token(self) -> Dict[str, str]:
        try:
            tmp = subprocess.run(
                ["gcloud", "auth", "print-identity-token"],
                stdout=subprocess.PIPE,
                universal_newlines=True,
            )
            if tmp.returncode != 0:
                raise RuntimeError("gcloud returned non-zero exit code")
            token = tmp.stdout.strip()
            return {
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
            }
        except Exception as e:
            raise RuntimeError(f"Error retrieving identity token: {e}") from e

    # ---------------- Subnet API call ----------------
    def get_subnet(
        self,
        input_cuis: Iterable[str],
        limit_context: Optional[List[str]] = None,
        cross_context: bool = False,
    ) -> Any:
        payload = {
            "cuis": list(input_cuis),
            "cross_context": cross_context,
        }
        if limit_context is not None:
            payload["limit_context"] = limit_context

        print("Payload:", payload)  # debug

        try:
            headers = self.get_token()
            res = requests.post(f"{self.url}/subnet/", headers=headers, json=payload)
            res.raise_for_status()
            output = res.json().get("output")
            return output
        except requests.HTTPError as e:
            raise RuntimeError(f"HTTP Error: {e}") from e
        except Exception as e:
            raise RuntimeError(f"Error retrieving subnet from API: {e}") from e

    # ---------------- Static helpers ----------------
    @staticmethod
    def base_cui(n: str) -> str:
        return n.split("-", 1)[0] if n.startswith("C") else n

    @staticmethod
    def _validate_cui_list(name, value, required: bool):
        if value is None:
            if required:
                raise ValueError(f"{name} is required and must be a list of CUIs.")
            return None
        try:
            items = list(value)
        except TypeError:
            raise TypeError(f"{name} must be an iterable of CUIs.")
        invalid = [x for x in items if not isinstance(x, str) or not CUI_RE.match(x)]
        if invalid:
            raise ValueError(f"{name} contains invalid CUIs: {invalid[:5]}")
        return items

    @staticmethod
    def _validate_str_list(name, value):
        if value is None:
            return None
        try:
            items = list(value)
        except TypeError:
            raise TypeError(f"{name} must be an iterable of strings.")
        invalid = [x for x in items if not isinstance(x, str)]
        if invalid:
            raise ValueError(f"{name} contains invalid strings: {invalid[:5]}")
        return items

    @staticmethod
    def build_digraph_from_subnet(subnet):
        try:
            nodes, edges = subnet
            G = nx.DiGraph()
            G.add_nodes_from(nodes)
            G.add_edges_from(edges)
            return G
        except Exception as e:
            raise RuntimeError(f"Error building digraph from subnet: {e}") from e

    # ---------------- Graph summarization ----------------
    def summarize_graph(
        self,
        subnet,
        target_cuis: Iterable[str]
    ) -> Dict[str, Dict[str, Any]]:

        G = self.build_digraph_from_subnet(subnet)
        G_rev = G.reverse(copy=False)

        results = {}

        for base_target in target_cuis:
            variants = [n for n in G.nodes if self.base_cui(n) == base_target]

            if not variants:
                results[base_target] = {
                    "target": base_target,
                    "target_variants": [],
                    "by_depth": {0: [base_target]},
                    "all_cuis": [base_target],
                    "total_cui_count": 1,
                }
                continue

            depth_map: Dict[str, int] = {}

            for v in variants:
                # Descendants (positive depth)
                down = nx.single_source_shortest_path_length(G, v)
                for node, depth in down.items():
                    if not CUI_RE.match(node):
                        continue
                    base = self.base_cui(node)
                    depth_map[base] = min(depth_map.get(base, depth), depth)

                # Ancestors (negative depth)
                up = nx.single_source_shortest_path_length(G_rev, v)
                for node, depth in up.items():
                    if not CUI_RE.match(node):
                        continue
                    base = self.base_cui(node)
                    signed_depth = -depth
                    if base not in depth_map:
                        depth_map[base] = signed_depth
                    else:
                        depth_map[base] = min(depth_map[base], signed_depth, key=abs)

            # Force target at depth 0
            depth_map[base_target] = 0

            # Group by depth
            by_depth: Dict[int, List[str]] = {}
            for cui, depth in depth_map.items():
                by_depth.setdefault(depth, []).append(cui)

            results[base_target] = {
                "by_depth": {d: sorted(v) for d, v in sorted(by_depth.items())},
                "all_cuis": sorted(depth_map.keys()),
                "total_cui_count": len(depth_map),
            }

        return results

    # ---------------- Main augment with batching ----------------
    def augment(
        self,
        target_cuis: Iterable[str],
        limit_context: Optional[List[str]] = None,
        batch_size: int = 10,
        max_workers: int = 5,  # number of threads
    ) -> Dict[str, Dict[str, Any]]:

        target_cuis = self._validate_cui_list("target_cuis", target_cuis, required=True)
        limit_context = self._validate_str_list("limit_context", limit_context)

        all_nodes = set()
        all_edges = set()

        # Split CUIs into batches
        batches = [target_cuis[i:i + batch_size] for i in range(0, len(target_cuis), batch_size)]

        def fetch_batch(batch):
            try:
                subnet_response = self.get_subnet(batch, limit_context)
                if subnet_response:
                    nodes, edges = subnet_response
                    return nodes, edges
            except Exception as e:
                print(f"Error fetching batch {batch}: {e}")
            return [], []

        # Parallel execution
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_batch = {executor.submit(fetch_batch, batch): batch for batch in batches}

            for future in as_completed(future_to_batch):
                nodes, edges = future.result()
                all_nodes.update(nodes)
                all_edges.update(edges)

        # Build a single graph from all batches
        G = nx.DiGraph()
        G.add_nodes_from(all_nodes)
        G.add_edges_from(all_edges)

        return self.summarize_graph((list(all_nodes), list(all_edges)), target_cuis)



client = AugmentCUI(URL)

target_cuis = ['C0003261', 'C0003264', 'C0003313', 'C0003314', 'C0004368', 'C0005532', 'C0005903', 'C0009528', 'C0009546', 'C0009547',
                  'C0018129', 'C0018133', 'C0019627', 'C0019699', 'C0020523', 'C0020964', 'C0020966', 'C0020967', 'C0020969', 'C0021055',
                  'C0021080', 'C0027651', 'C0035203', 'C0037088', 'C0040735', 'C0085416', 'C0152036', 'C0178498', 'C0178575', 'C0178709', 
                  'C0206120', 'C0239998', 'C0282558', 'C0301896', 'C0312535', 'C0338370', 'C0427349', 'C0428033', 'C0428047', 'C0457936', 
                  'C0458064', 'C0458065', 'C0458066', 'C0458067', 'C0458068', 'C0458069', 'C0458070', 'C0458071', 'C0458072', 'C0458073',
                  'C0458074', 'C0481430', 'C0516983', 'C0517595', 'C0517597', 'C0517599', 'C0518656', 'C0518883', 'C0520990', 'C0582172', 
                  'C0588457', 'C0596117', 'C0596177', 'C0596829', 'C0597140', 'C0678209', 'C0678656', 'C0678852', 'C0678885', 'C0700205', 
                  'C0749722', 'C0920352', 'C1135927', 'C1140093', 'C1140118', 'C1140162', 'C1140168', 'C1262477', 'C1274016', 'C1274019',
                  'C1277676', 'C1285578', 'C1286235', 'C1287242', 'C1305430', 'C1319220', 'C1319289', 'C1320403', 'C1320991', 'C1443394',
                  'C1513731', 'C1553844', 'C1553931', 'C1609987', 'C1699089', 'C1817756', 'C1820730', 'C1820731', 'C1820732', 'C1820733', 
                  'C1820734', 'C1820735', 'C1820736', 'C2711893', 'C2720507', 'C3714634', 'C4716274', 'C5234945', 'C5699729', 'C5788868', 
                  'C5788869', 'C5788870', 'C5788871', 'C5788908', 'C5788909', 'C5788910', 'C5788911', 'C5788912', 'C5788913', 'C5788914',
                  'C5788915', 'C5788916', 'C5788917', 'C5788918', 'C5788919', 'C5788920', 'C5788921', 'C5788922', 'C5788923', 'C5788924',
                  'C5788925', 'C5788926', 'C5788927', 'C5788928', 'C5788929', 'C5788930', 'C5817380']
limit_context = [
    'LNC.Empty', 'SNOMEDCT_US.Empty', 'SNOMEDCT_US.isa',
    'ICD10.Empty', 'ICD10AM.Empty', 'ICD10CM.Empty',
    'ICD10PCS.Empty', 'CCSR_ICD10PCS.Empty'
]

try:
    response = client.augment(
        target_cuis=target_cuis,
        limit_context=limit_context
    )
    print("\nFinal output (CUIs only):\n", response)
except Exception as e:
    print("Error:", e)
