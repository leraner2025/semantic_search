The purpose of this user story is to implement the CUI compacting logic as part of the CUI Matching feature. This logic was previously designed by the capability team to reduce and consolidate large sets of CUIs that often emerge during the entity-to-CUI matching process.

When entities are extracted from clinical text, the initial CUI list produced by the matching pipeline can be extensive, containing:

Multiple CUIs with overlapping semantic meaning

CUIs from different or lesser-known coding systems

CUIs that represent overly granular or redundant concepts

This volume and redundancy create challenges for downstream workflows such as entity linking, shopping list matching, and clinical concept retrieval.

This story focuses on implementing a compacting module that:

Ingests a raw list of CUIs generated during the CUI Matching workflow

Applies the tree-based reduction logic developed by the capability team to cluster, normalize, and prune redundant CUIs

Outputs a smaller, clinically meaningful, and standardized list of CUIs aligned with the systems used for the ODE retrieval process (e.g., nature breakdown CUIs)

The module may operate at a block level, enabling reduction within localized text sections, but it should also support document-level flexibility.
The compacted list is essential to ensure that the downstream CUI Matching results remain accurate, efficient, and usable for specialty workflows and final recommendation logic.

----------------------------------------------------------------------------------------------------------

Previous the capability team developed a tree-based logic to reduce the number of CUIS originally extracted from a note, so that the note can be represented by a smaller of CUIS, rather than a large number of CUIS that have overlap semantics. This story focuses on implementing this logic into a module(s) that:
Takes in a list of CUIS
Outputs a smaller list of CUIS

Dev Notes:
Maybe operate at the block level
A initial list of CUIs extracted from NER-as-a-service may consist of CUIs from multiple lesser known coding systems. The compact list should consider the systems that will be matchable to the shopping list items (i.e. the nature breakdown CUIs) so they can be used in the retrieval process.


-----------------------------------------------------------------------------------------------------

Acceptance ccriteria: Input Handling
Module accepts a list of CUIs from the CUI Matching process.

Supports mixed coding systems without errors.

Compacting Logic
Implements the tree-based hierarchical reduction logic created by the capability team.

Removes redundant, overlapping, or semantically similar CUIs.

Prioritizes CUIs relevant to downstream ODE retrieval systems (e.g., nature breakdown).

Produces a meaningfully smaller, clinically representative set of CUIs.

Output Requirements
Returns a compacted list of CUIs optimized for use in subsequent CUI Matching steps.

Output is deterministic and stable for identical inputs.

Quality & Performance
Compacting logic executes within acceptable performance bounds.

Unit tests validate:

correct pruning behavior

mixed-system inputs

hierarchical reductions

edge cases where few or no CUIs remain

Documentation
Documentation is added describing:

compacting rules and heuristic logic

input/output format

known limitations

integration points within the CUI Matching workflow







| **Acceptance Criteria**                                                                            | **Fixed IC Threshold**       | **Percentile-based Threshold** | **Target-Reduction Iterative Threshold** | **Comment / Fit**                                                                         |
| -------------------------------------------------------------------------------------------------- | ---------------------------- | ------------------------------ | ---------------------------------------- | ----------------------------------------------------------------------------------------- |
| **Module accepts a list of CUIs from the CUI Matching process**                                    | ✅ Works                      | ✅ Works                        | ✅ Works                                  | All methods can ingest the input list.                                                    |
| **Supports mixed coding systems without errors**                                                   | ✅ Works                      | ✅ Works                        | ✅ Works                                  | Thresholding doesn’t affect coding system compatibility.                                  |
| **Implements tree-based hierarchical reduction logic**                                             | ✅ Works                      | ✅ Works                        | ✅ Works                                  | Threshold selection is just a trigger for rollup; logic remains same.                     |
| **Removes redundant, overlapping, or semantically similar CUIs**                                   | ⚠ Partially                  | ⚠ Better than fixed            | ✅ Fully controlled                       | Fixed threshold may under- or over-rollup; target reduction ensures desired pruning.      |
| **Prioritizes CUIs relevant to downstream ODE retrieval systems**                                  | ⚠ Depends on IC distribution | ⚠ Partial                      | ✅ Fully controlled                       | Target-reduction can integrate additional prioritization rules.                           |
| **Produces a meaningfully smaller, clinically representative set of CUIs**                         | ⚠ Often inconsistent         | ⚠ Adaptive, but may vary       | ✅ Guaranteed                             | Iterative reduction ensures target size and clinical meaningfulness.                      |
| **Returns a compacted list optimized for use in subsequent steps**                                 | ⚠ Sometimes                  | ⚠ Often                        | ✅ Always                                 | Only iterative reduction guarantees consistent downstream-ready list.                     |
| **Output is deterministic and stable for identical inputs**                                        | ✅ Deterministic              | ✅ Deterministic                | ✅ Deterministic                          | All deterministic if implemented carefully; iterative may require tie-breaking rules.     |
| **Compacting logic executes within acceptable performance bounds**                                 | ✅ Fastest                    | ✅ Fast                         | ⚠ Slightly slower due to iterations      | Iterative approach may add small overhead, but usually negligible for typical list sizes. |
| **Unit tests validate pruning behavior, mixed-system inputs, hierarchical reductions, edge cases** | ✅ Testable                   | ✅ Testable                     | ✅ Testable                               | Iterative method allows testing across different reduction percentages.                   |
| **Documentation describes rules, I/O, limitations, integration points**                            | ✅ Same                       | ✅ Same                         | ✅ Same                                   | No difference; implementation choice only affects heuristic section.                      |
