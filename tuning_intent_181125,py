egde cases taken for the fine tuning 
Ambiguous queries

Multi-intent queries

Temporal references (like "last week" or "6 months ago")

Misspellings / slang

Deterministic topic matching using entities

Fallback keyword matching

LLM hallucination / JSON parsing errors



import json
import re
from datetime import datetime, timedelta
import dateparser.search
from google import genai
from google.genai import types


class SmartMedicalAdapter:
    def __init__(self, project_id: str, location: str = "us-central1", model_name: str = "gemini-2.5-flash-lite"):
        self.client = genai.Client(
            vertexai=True,
            project=project_id,
            location=location,
        )
        self.model_name = model_name
        self.topics = self._load_demo_topics()
        self.today = datetime.today()

    def _load_demo_topics(self):
        # Demo topics with scan_date (ISO format)
        return [
            {"title": "MRI Results", "description": "Patient underwent an MRI scan. Results showed mild inflammation.", "scan_date": "2025-11-10"},
            {"title": "MRI Results", "description": "Latest MRI scan shows no new abnormalities.", "scan_date": None},
            {"title": "Liver Function", "description": "Blood tests revealed elevated liver enzymes.", "scan_date": "2025-11-05"},
            {"title": "Medication History", "description": "Patient was prescribed warfarin and lisinopril.", "scan_date": None},
            {"title": "CT Scan", "description": "CT scan of the brain showed no abnormalities.", "scan_date": "2025-11-08"}
        ]

    # ------------------------ LLM Helper ------------------------
    def _call_model(self, prompt: str) -> str:
        part = types.Part()
        part.text = prompt
        contents = [types.Content(role="user", parts=[part])]
        generate_content_config = types.GenerateContentConfig(
            temperature=0.7,
            top_p=0.95,
            max_output_tokens=2048,
        )
        response = self.client.models.generate_content(
            model=self.model_name,
            contents=contents,
            config=generate_content_config,
        )
        return response.text.strip()

    # ------------------------ Medical Domain Check ------------------------
    def _is_medical_query(self, query: str) -> bool:
        prompt = f"""
Determine if the following query is clinically relevant for a medical context.
Respond only with 'Yes' or 'No'.

Query: {query}
"""
        response = self._call_model(prompt).lower()
        return "yes" in response

    # ------------------------ Temporal Parsing ------------------------
    def _get_temporal_context(self, query: str):
        parsed_dates = dateparser.search.search_dates(query, settings={'RELATIVE_BASE': self.today})
        query_lower = query.lower()

        # Default relative ranges for recent/latest
        if "recent" in query_lower or "latest" in query_lower:
            return self.today - timedelta(days=7), self.today

        # Explicit relative phrases like "last 2 weeks"
        relative_match = re.search(r'last (\d+) (day|week|month|year)s?', query_lower)
        if relative_match:
            num, unit = int(relative_match.group(1)), relative_match.group(2)
            if unit == "day":
                return self.today - timedelta(days=num), self.today
            elif unit == "week":
                return self.today - timedelta(weeks=num), self.today
            elif unit == "month":
                return self.today - timedelta(days=30 * num), self.today
            elif unit == "year":
                return self.today - timedelta(days=365 * num), self.today

        # Explicit dates
        if parsed_dates:
            dates = [dt for _, dt in parsed_dates]
            return min(dates), max(dates)

        return None, None

    # ------------------------ Query Expansion ------------------------
    def _expand_query(self, query: str) -> str:
        start_date, end_date = self._get_temporal_context(query)
        temporal_text = f"Start: {start_date.strftime('%B %d, %Y')}, End: {end_date.strftime('%B %d, %Y')}" if start_date else "No explicit date"
        prompt = f"""
You are a medical AI assistant. Expand the user query for better search.

Temporal info: {temporal_text}
Original Query: {query}
Expanded Query:
"""
        return self._call_model(prompt)

    # ------------------------ Extract Intents and Entities (Improved) ------------------------
    def _extract_intents_entities(self, query: str) -> dict:
        start_date, end_date = self._get_temporal_context(query)
        temporal_hint = f"Start: {start_date.strftime('%B %d, %Y')}, End: {end_date.strftime('%B %d, %Y')}" if start_date else "No explicit date"

        prompt = f"""
You are a highly accurate medical AI assistant. Your job is to extract the user's **intent(s)** and **entities** from the query.
- Intent: what action or information the user is requesting (e.g., 'get_lab_results', 'schedule_scan', 'medication_history')
- Entities: relevant medical items like 'MRI', 'CT scan', 'liver function', 'warfarin', etc.
- Temporal: consider words like 'latest', 'recent', 'last week', 'last month' and map them to start/end dates.

Examples:
Query: "latest MRI"
Intent: ["get_scan_results"]
Entities: ["MRI"]
Query: "blood tests from last month"
Intent: ["get_lab_results"]
Entities: ["blood tests"]
Query: "medication history"
Intent: ["get_medication_history"]
Entities: []

Now extract intents and entities for the following query:

Temporal context: {temporal_hint}
Query: "{query}"

Respond ONLY in JSON with keys:
{{ "intents": [...], "entities": [...], "formatted_query": "..." }}
"""
        response_text = self._call_model(prompt)
        try:
            json_text_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if json_text_match:
                return json.loads(json_text_match.group(0))
            return json.loads(response_text)
        except json.JSONDecodeError:
            # Fallback
            return {"intents": [], "entities": [], "formatted_query": query}

    # ------------------------ Topic Filtering ------------------------
    def _filter_topics(self, query: str, intents: list, entities: list) -> list:
        start_date, end_date = self._get_temporal_context(query)
        relevant_topics = []

        # 1. Filter by date if present
        for topic in self.topics:
            topic_date_str = topic.get("scan_date")
            topic_date = datetime.strptime(topic_date_str, "%Y-%m-%d") if topic_date_str else None
            if topic_date and start_date and end_date:
                if start_date <= topic_date <= end_date:
                    relevant_topics.append(topic)

        # 2. If none found, fallback to "latest" or "recent" in description
        if not relevant_topics:
            for topic in self.topics:
                if re.search(r'\b(latest|recent)\b', topic["description"].lower()):
                    relevant_topics.append(topic)

        # 3. Final fallback: pick first topic if still none
        if not relevant_topics:
            relevant_topics = [self.topics[0]] if self.topics else []

        return relevant_topics

    # ------------------------ Generate Answer ------------------------
    def _generate_answer(self, query: str, intents: list, entities: list, topics: list) -> dict:
        context = "\n".join([f"{t['title']}: {t['description']}" for t in topics[:3]])
        prompt = f"""
You are a medical AI assistant. Based on the following topics, provide an answer and pick the most relevant topic title.

Intents: {', '.join(intents) if intents else 'None'}
Entities: {', '.join(entities) if entities else 'None'}

Patient Topics:
{context}

Query:
{query}

Respond ONLY in JSON: {{ "answer": "...", "matched_topic_title": "..." }}
"""
        response_text = self._call_model(prompt)
        try:
            json_text_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if json_text_match:
                return json.loads(json_text_match.group(0))
            return {"answer": response_text.strip(), "matched_topic_title": None}
        except json.JSONDecodeError:
            return {"answer": response_text.strip(), "matched_topic_title": None}

    # ------------------------ Main Entry ------------------------
    def answer_query(self, query: str) -> dict:
        if not self._is_medical_query(query):
            return {
                "original_query": query,
                "expanded_query": None,
                "formatted_query": None,
                "intents": [],
                "entities": [],
                "matched_topic_titles": [],
                "answer": "The query is not medically relevant."
            }

        expanded_query = self._expand_query(query)
        extraction = self._extract_intents_entities(expanded_query)
        intents = extraction.get("intents", [])
        entities = extraction.get("entities", [])
        formatted_query = extraction.get("formatted_query", expanded_query)

        relevant_topics = self._filter_topics(formatted_query, intents, entities)
        answer_data = self._generate_answer(formatted_query, intents, entities, relevant_topics)
        matched_title = answer_data.get("matched_topic_title")
        matched_titles = [matched_title] if matched_title else [t["title"] for t in relevant_topics[:1]]

        return {
            "original_query": query,
            "expanded_query": expanded_query,
            "formatted_query": formatted_query,
            "intents": intents,
            "entities": entities,
            "matched_topic_titles": matched_titles,
            "answer": answer_data.get("answer", "")
        }


# ------------------------ Example Usage ------------------------
if __name__ == "__main__":
    PROJECT_ID = "YOUR_PROJECT_ID"
    adapter = SmartMedicalAdapter(project_id=PROJECT_ID)

    queries = [
        "MRI results for last week",
        "latest MRI",
        "recent CT scan",
        "medication history",
        "What's the weather today?"  # Non-medical
    ]

    for q in queries:
        resp = adapter.answer_query(q)
        print("\n---")
        print("Query:", q)
        print("Matched Topics:", resp["matched_topic_titles"])
        print("Intents:", resp["intents"])
        print("Entities:", resp["entities"])
        print("Answer:", resp["answer"])

